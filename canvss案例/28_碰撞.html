<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>碰撞</title>
	</head>
	<body>
	<script type="text/javascript" src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
		<canvas id="canvas" width="500px" height="500px" style="border:1px solid pink"></canvas>
		<button  id="startAnimation" value="start">start</button>
		<button  id="stopAnimation" value="stop">stop</button>
		
<script>
		var canvas=document.getElementById("canvas");//找到画布元素
		var context=canvas.getContext("2d");//2d环境
		var imageData = context.createImageData(500, 500);//创建一个500×500透明像素区域的ImageData 对象
		var pixels = imageData.data; //变量pixels用作访问canvas中像素的快捷方式
		
		var x = 0;//用于保存当前正方形的x位置
		
		x++;//更新正方形的x位置，每循环一次该值增加1
		context.clearRect(0, 0, canvasWidth, canvasHeight); //清除画布
        context.fillRect(x, 75, 50, 50);//绘制图形
		
		var canvasWidth=canvas.width;
		var canvasHeight = canvas.height; 
 		
 		//给两个按钮添加功能
		var playAnimation = true;  
		var startButton =$("#startAnimation"); 
		var stopButton = $("#stopAnimation"); 
		startButton.hide(); //开始按钮隐藏

		startButton.click(function() { //触发开始事件
			$(this).hide(); //隐藏当前按钮
			stopButton.show(); //停止按钮显示
 
			playAnimation = true; //动画播放
			animate(); 
		}); 
 
		stopButton.click(function() { //触发停止事件
			$(this).hide(); //隐藏当前按钮
			startButton.show(); //开始按钮显示
 
			playAnimation = false; //动画停止
		}); 
 		//该动画对象（类）是一个形状（Shape），然后我们提取Shape的一些基本属性
		var Shape = function(x, y, width, height) { 
			this.x = x; 
			this.y = y; 
			this.width = width; 
			this.height = height; 
		}; 
 		//产生随机形状,需要更改Shape类来定义形状的宽度和高度
		var shapes = new Array(); 
		for (var i = 0; i < 10; i++) {         
			var x = Math.random()*250;
			var y = Math.random()*250; 
			var width = height = Math.random()*30; 
			shapes.push(new Shape(x, y, width, height)); 
			
			//定义形状是否碰到边界及反弹的路径方向
			this.reverseX=false; 
            this.reverseY=false;
			
		}; 
 		//将这些形状从数组中取出来并更新它们的位置（使它们产生动画效果），然后绘制这些形状
		function animate() { 
			context.clearRect(0, 0, canvasWidth, canvasHeight); 
 
			var shapesLength = shapes.length;
			
		
			for (var i = 0; i < shapesLength; i++) { 
				var tmpShape = shapes[i]; 
					//当形状即将到达边界之外时，这些检查将反向改变形状的运动路线。但是，设置布尔值并不能实际改变形状的具体运动方向，因此，需要另外进行一些检查,需要把他们放到fillRect调用上面
					if (!tmpShape.reverseX) { 
						tmpShape.x += 2; 
					} else { 
						tmpShape.x -= 2; 
					}; 
 
					if (!tmpShape.reverseY) { 
						tmpShape.y += 2; 
					} else { 
						tmpShape.y -= 2; 
					};
				
				//将新的x和y变量添加到fillRect
				context.fillRect(tmpShape.x, tmpShape.y, tmpShape.width, tmpShape.height); 
				
				//添加逻辑关系来检查形状是否超出了画布边界
				if (tmpShape.x < 0) { 
					tmpShape.reverseX = false; 
				} else if (tmpShape.x + tmpShape.width > canvasWidth) { 
					tmpShape.reverseX = true; 
				}; 
 
				if (tmpShape.y < 0) { 
					tmpShape.reverseY = false; 
				} else if (tmpShape.y + tmpShape.height > canvasHeight) { 
					tmpShape.reverseY = true; 
				};
				
			}; 
 			//控制播放
			if (playAnimation) { 
				setTimeout(animate, 33); 
			}; 
		}; 
 
		animate();
	</script>
	</body>
</html>
